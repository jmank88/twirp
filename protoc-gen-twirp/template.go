package main

import (
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
)

type tmplData struct {
	Version            string
	SourceName         string
	FirstFile          bool
	FileComment        string
	Deps               map[string]string
	GenPackageName     string
	PackageName        string
	ProtoFiles         []*descriptor.FileDescriptorProto
	Services           []Service
	FileDescriptorName string
	FileDescriptorLen  string
	FileDescriptor     string
	ServiceTypeNames   []string
}

type Service struct {
	Name      string
	NameLower string
	Comment   string
	Methods   []Method
	FullName  string
}

type Method struct{ Name, Req, Resp, Comment string }

// TODO need to quote things better? carefully anyways (strconv.Quote)
var fileTmplStr = `
// Code generated by protoc-gen-twirp {{$.Version}}, DO NOT EDIT.
// source: {{.SourceName}}

{{if .FirstFile}}
/*
Package {{.GenPackageName}} is a generated twirp stub package.
This code was generated with github.com/twitchtv/twirp/protoc-gen-twirp {{$.Version}}.

{{if .FileComment}}{{.FileComment}}{{end}}It is generated from these files:
{{range .ProtoFiles}}	{{.GetName}}
{{end}}*/{{end}}
package {{.GenPackageName}}

import {{pkgs "bytes"}} "bytes"
import {{pkgs "context"}} "context"
import {{pkgs "fmt"}} "fmt"
import {{pkgs "ioutil"}} "io/ioutil"
import {{pkgs "log"}} "log"
import {{pkgs "http"}} "net/http"

import {{pkgs "jsonpb"}} "github.com/golang/protobuf/jsonpb"
import {{pkgs "proto"}} "github.com/golang/protobuf/proto"
import {{pkgs "twirp"}} "github.com/twitchtv/twirp"
import {{pkgs "ctxsetters"}} "github.com/twitchtv/twirp/ctxsetters"
{{if .Deps}}
{{range $pkg, $path := .Deps}}
import {{$pkg}} {{$path}}
{{end}}

{{end}}
{{if .FirstFile}}
// Imports only used by utility functions:
import {{pkgs "io"}} "io"
import {{pkgs "strconv"}} "strconv"
import {{pkgs "json"}} "encoding/json"
import {{pkgs "url"}} "net/url"

{{end}}
{{range $service := .Services}}
{{sectionComment (print $service.Name " Interface")}}

{{$service.Comment}}type {{$service.Name}} interface {
{{range $idx, $method := $service.Methods}}{{if eq $idx 1}}{{print "\n"}}{{end}}{{if $method.Comment}}	{{$method.Comment}}{{end}}{{$method.Name}}({{pkgs "context"}}.Context, *{{$method.Req}}) (*{{$method.Resp}}, error)
{{end}}
}

{{range $name := $.ServiceTypeNames}}
{{sectionComment (print $service.Name " " $name " Client")}}

type {{$service.NameLower}}{{$name}}Client struct {
	client HTTPClient
	urls   [{{len $service.Methods}}]string
}

// New{{$service.Name}}{{$name}}Client creates a {{$name}} client that implements the {{$service.Name}} interface.
// It communicates using {{$name}} and can be configured with a custom HTTPClient.
func New{{$service.Name}}{{$name}}Client(addr string, client HTTPClient) {{$service.Name}} {
	prefix := urlBase(addr) + {{$service.Name}}PathPrefix
	urls := [{{len $service.Methods}}]string{
{{range $service.Methods}}		prefix + "{{.Name}}",
{{end}}
	}
	if httpClient, ok := client.(*{{pkgs "http"}}.Client); ok {
		return &{{$service.NameLower}}{{$name}}Client{
			client: withoutRedirects(httpClient),
			urls:   urls,
		}
	}
	return &{{$service.NameLower}}{{$name}}Client{
		client: client,
		urls:   urls,
	}
}

	{{range $idx, $method := $service.Methods}}
func (c *{{$service.NameLower}}{{$name}}Client) {{$method.Name}}(ctx {{pkgs "context"}}.Context, in *{{$method.Req}}) (*{{$method.Resp}}, error) {
	out := new({{$method.Resp}})
	err := do{{$name}}Request(ctx, c.client, c.urls[{{$idx}}], in, out)
	return out, err
}
	{{end}}

{{end}}

{{sectionComment (print $service.Name " Server Handler")}}

type {{$service.NameLower}}Server struct {
	{{$service.Name}}
	hooks *{{pkgs "twirp"}}.ServerHooks
}

func New{{$service.Name}}Server(svc {{$service.Name}}, hooks *{{pkgs "twirp"}}.ServerHooks) TwirpServer {
	return &{{$service.NameLower}}Server{
		{{$service.Name}}:   svc,
		hooks: hooks,
	}
}

// writeError writes an HTTP response with a valid Twirp error format, and triggers hooks.
// If err is not a {{pkgs "twirp"}}.Error, it will get wrapped with {{pkgs "twirp"}}.InternalErrorWith(err)
func (s *{{$service.NameLower}}Server) writeError(ctx {{pkgs "context"}}.Context, resp {{pkgs "http"}}.ResponseWriter, err error) {
	writeError(ctx, resp, err, s.hooks)
}

// {{$service.Name}}PathPrefix is used for all URL paths on a twirp {{$service.Name}} server.
// Requests are always: POST {{$service.Name}}PathPrefix/method
// It can be used in an HTTP mux to route twirp requests along with non-twirp requests on other routes.
const {{$service.Name}}PathPrefix = "{{$service.FullName}}"

func (s *{{$service.NameLower}}Server) ServeHTTP(resp {{pkgs "http"}}.ResponseWriter, req *{{pkgs "http"}}.Request) {
	ctx := req.Context()
	ctx = {{pkgs "ctxsetters"}}.WithPackageName(ctx, "{{$.PackageName}}")
	ctx = {{pkgs "ctxsetters"}}.WithServiceName(ctx, "{{$service.Name}}")
	ctx = {{pkgs "ctxsetters"}}.WithResponseWriter(ctx, resp)

	var err error
	ctx, err = callRequestReceived(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	if req.Method != "POST" {
		msg := {{pkgs "fmt"}}.Sprintf("unsupported method %q (only POST is allowed)", req.Method)
		err = badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, err)
		return
	}

	switch req.URL.Path {
	{{range $method := $service.Methods}}case "{{$service.FullName}}{{$method.Name}}":
		s.serve{{$method.Name}}(ctx, resp, req)
		return
{{end}}	default:
		msg := {{pkgs "fmt"}}.Sprintf("no handler for path %q", req.URL.Path)
		err = badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, err)
		return
	}
}

{{range $method := $service.Methods}}
func (s *{{$service.NameLower}}Server) serve{{$method.Name}}(ctx {{pkgs "context"}}.Context, resp {{pkgs "http"}}.ResponseWriter, req *{{pkgs "http"}}.Request) {
	switch req.Header.Get("Content-Type") {
	case "application/json":
		s.serve{{$method.Name}}JSON(ctx, resp, req)
	case "application/protobuf":
		s.serve{{$method.Name}}Protobuf(ctx, resp, req)
	default:
		msg := {{pkgs "fmt"}}.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *{{$service.NameLower}}Server) serve{{$method.Name}}JSON(ctx {{pkgs "context"}}.Context, resp {{pkgs "http"}}.ResponseWriter, req *{{pkgs "http"}}.Request) {
	var err error
	ctx = {{pkgs "ctxsetters"}}.WithMethodName(ctx, "{{$method.Name}}")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	defer closebody(req.Body)
	reqContent := new({{$method.Req}})
	unmarshaler := {{pkgs "jsonpb"}}.Unmarshaler{AllowUnknownFields: true}
	if err = unmarshaler.Unmarshal(req.Body, reqContent); err != nil {
		err = wrapErr(err, "failed to parse request json")
		s.writeError(ctx, resp, {{pkgs "twirp"}}.InternalErrorWith(err))
		return
	}

	// Call service method
	var respContent *{{$method.Resp}}
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if r := recover(); r != nil {
				s.writeError(ctx, resp, {{pkgs "twirp"}}.InternalError("Internal service panic"))
				panic(r)
			}
		}()
		respContent, err = s.{{$method.Name}}(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, {{pkgs "twirp"}}.InternalError("received a nil *{{$method.Resp}} and nil error while calling {{$method.Name}}. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	var buf {{pkgs "bytes"}}.Buffer
	marshaler := &{{pkgs "jsonpb"}}.Marshaler{OrigName: true}
	if err = marshaler.Marshal(&buf, respContent); err != nil {
		err = wrapErr(err, "failed to marshal json response")
		s.writeError(ctx, resp, {{pkgs "twirp"}}.InternalErrorWith(err))
		return
	}

	ctx = {{pkgs "ctxsetters"}}.WithStatusCode(ctx, {{pkgs "http"}}.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.WriteHeader({{pkgs "http"}}.StatusOK)
	if _, err = resp.Write(buf.Bytes()); err != nil {
		{{pkgs "log"}}.Printf("errored while writing response to client, but already sent response status code to 200: %s", err)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *{{$service.NameLower}}Server) serve{{$method.Name}}Protobuf(ctx {{pkgs "context"}}.Context, resp {{pkgs "http"}}.ResponseWriter, req *{{pkgs "http"}}.Request) {
	var err error
	ctx = {{pkgs "ctxsetters"}}.WithMethodName(ctx, "{{$method.Name}}")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	defer closebody(req.Body)
	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		err = wrapErr(err, "failed to read request body")
		s.writeError(ctx, resp, {{pkgs "twirp"}}.InternalErrorWith(err))
		return
	}
	reqContent := new({{$method.Req}})
	if err = {{pkgs "proto"}}.Unmarshal(buf, reqContent); err != nil {
		err = wrapErr(err, "failed to parse request proto")
		s.writeError(ctx, resp, {{pkgs "twirp"}}.InternalErrorWith(err))
		return
	}

	// Call service method
	var respContent *{{$method.Resp}}
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if r := recover(); r != nil {
				s.writeError(ctx, resp, {{pkgs "twirp"}}.InternalError("Internal service panic"))
				panic(r)
			}
		}()
		respContent, err = s.{{$method.Name}}(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, {{pkgs "twirp"}}.InternalError("received a nil *{{$method.Resp}} and nil error while calling {{$method.Name}}. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := {{pkgs "proto"}}.Marshal(respContent)
	if err != nil {
		err = wrapErr(err, "failed to marshal proto response")
		s.writeError(ctx, resp, {{pkgs "twirp"}}.InternalErrorWith(err))
		return
	}

	ctx = {{pkgs "ctxsetters"}}.WithStatusCode(ctx, {{pkgs "http"}}.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.WriteHeader({{pkgs "http"}}.StatusOK)
	if _, err = resp.Write(respBytes); err != nil {
		{{pkgs "log"}}.Printf("errored while writing response to client, but already sent response status code to 200: %s", err)
	}
	callResponseSent(ctx, s.hooks)
}
{{end}}

func (s *{{$service.NameLower}}Server) ServiceDescriptor() ([]byte, int) {
	return {{$.FileDescriptorName}}, 0
}

func (s *{{$service.NameLower}}Server) ProtocGenTwirpVersion() string {
	return "{{$.Version}}"
}
{{end}}

{{if .FirstFile}}
{{sectionComment "Utils"}}

// HTTPClient is the interface used by generated clients to send HTTP requests.
// It is fulfilled by *(net/http).Client, which is sufficient for most users.
// Users can provide their own implementation for special retry policies.
//
// HTTPClient implementations should not follow redirects. Redirects are
// automatically disabled if *(net/http).Client is passed to client
// constructors. See the withoutRedirects function in this file for more
// details.
type HTTPClient interface {
	Do(req *{{pkgs "http"}}.Request) (*{{pkgs "http"}}.Response, error)
}

// TwirpServer is the interface generated server structs will support: they're
// HTTP handlers with additional methods for accessing metadata about the
// service. Those accessors are a low-level API for building reflection tools.
// Most people can think of TwirpServers as just {{pkgs "http"}}.Handlers.
type TwirpServer interface {
	{{pkgs "http"}}.Handler
	// ServiceDescriptor returns gzipped bytes describing the .proto file that
	// this service was generated from. Once unzipped, the bytes can be
	// unmarshalled as a
	// github.com/golang/protobuf/protoc-gen-go/descriptor.FileDescriptorProto.
	//
	// The returned integer is the index of this particular service within that
	// FileDescriptorProto's 'Service' slice of ServiceDescriptorProtos. This is a
	// low-level field, expected to be used for reflection.
	ServiceDescriptor() ([]byte, int)
	// ProtocGenTwirpVersion is the semantic version string of the version of
	// twirp used to generate this file.
	ProtocGenTwirpVersion() string
}

// WriteError writes an HTTP response with a valid Twirp error format.
// If err is not a {{pkgs "twirp"}}.Error, it will get wrapped with {{pkgs "twirp"}}.InternalErrorWith(err)
func WriteError(resp {{pkgs "http"}}.ResponseWriter, err error) {
	writeError({{pkgs "context"}}.Background(), resp, err, nil)
}

// writeError writes Twirp errors in the response and triggers hooks.
func writeError(ctx {{pkgs "context"}}.Context, resp {{pkgs "http"}}.ResponseWriter, err error, hooks *{{pkgs "twirp"}}.ServerHooks) {
	// Non-twirp errors are wrapped as Internal (default)
	twerr, ok := err.({{pkgs "twirp"}}.Error)
	if !ok {
		twerr = {{pkgs "twirp"}}.InternalErrorWith(err)
	}

	statusCode := {{pkgs "twirp"}}.ServerHTTPStatusFromErrorCode(twerr.Code())
	ctx = {{pkgs "ctxsetters"}}.WithStatusCode(ctx, statusCode)
	ctx = callError(ctx, hooks, twerr)

	resp.Header().Set("Content-Type", "application/json") // Error responses are always JSON (instead of protobuf)
	resp.WriteHeader(statusCode)                          // HTTP response status code

	respBody := marshalErrorToJSON(twerr)
	_, err2 := resp.Write(respBody)
	if err2 != nil {
		{{pkgs "log"}}.Printf("unable to send error message %q: %s", twerr, err2)
	}

	callResponseSent(ctx, hooks)
}

// urlBase helps ensure that addr specifies a scheme. If it is unparsable
// as a URL, it returns addr unchanged.
func urlBase(addr string) string {
	// If the addr specifies a scheme, use it. If not, default to
	// http. If {{pkgs "url"}}.Parse fails on it, return it unchanged.
	url, err := {{pkgs "url"}}.Parse(addr)
	if err != nil {
		return addr
	}
	if url.Scheme == "" {
		url.Scheme = "http"
	}
	return url.String()
}

// getCustomHTTPReqHeaders retrieves a copy of any headers that are set in
// a context through the {{pkgs "twirp"}}.WithHTTPRequestHeaders function.
// If there are no headers set, or if they have the wrong type, nil is returned.
func getCustomHTTPReqHeaders(ctx {{pkgs "context"}}.Context) {{pkgs "http"}}.Header {
	header, ok := {{pkgs "twirp"}}.HTTPRequestHeaders(ctx)
	if !ok || header == nil {
		return nil
	}
	copied := make({{pkgs "http"}}.Header)
	for k, vv := range header {
		if vv == nil {
			copied[k] = nil
			continue
		}
		copied[k] = make([]string, len(vv))
		copy(copied[k], vv)
	}
	return copied
}

// closebody closes a response or request body and just logs
// any error encountered while closing, since errors are
// considered very unusual.
func closebody(body io.Closer) {
	if err := body.Close(); err != nil {
		{{pkgs "log"}}.Printf("error closing body: %q", err)
	}
}

// newRequest makes an {{pkgs "http"}}.Request from a client, adding common headers.
func newRequest(ctx {{pkgs "context"}}.Context, url string, reqBody io.Reader, contentType string) (*{{pkgs "http"}}.Request, error) {
	req, err := {{pkgs "http"}}.NewRequest("POST", url, reqBody)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if customHeader := getCustomHTTPReqHeaders(ctx); customHeader != nil {
			req.Header = customHeader
	}
	req.Header.Set("Content-Type", contentType)
	req.Header.Set("Twirp-Version", "{{$.Version}}")
	return req, nil
}

// JSON serialization for errors
type twerrJSON struct {
` + "	Code string            `json:\"code\"`\n" +
	"	Msg  string            `json:\"msg\"`\n" +
	"	Meta map[string]string `json:\"meta,omitempty\"`" + `
}

// marshalErrorToJSON returns JSON from a {{pkgs "twirp"}}.Error, that can be used as HTTP error response body.
// If serialization fails, it will use a descriptive Internal error instead.
func marshalErrorToJSON(twerr {{pkgs "twirp"}}.Error) []byte {
	// make sure that msg is not too large
	msg := twerr.Msg()
	if len(msg) > 1e6 {
		msg = msg[:1e6]
	}

	tj := twerrJSON{
		Code: string(twerr.Code()),
		Msg:  msg,
		Meta: twerr.MetaMap(),
	}

	buf, err := {{pkgs "json"}}.Marshal(&tj)
	if err != nil {
		buf = []byte("{\"type\": \"" + {{pkgs "twirp"}}.Internal + "\", \"msg\": \"There was an error but it could not be serialized into JSON\"}") // fallback
	}

	return buf
}

// errorFromResponse builds a {{pkgs "twirp"}}.Error from a non-200 HTTP response.
// If the response has a valid serialized Twirp error, then it's returned.
// If not, the response status code is used to generate a similar twirp
// error. See twirpErrorFromIntermediary for more info on intermediary errors.
func errorFromResponse(resp *{{pkgs "http"}}.Response) {{pkgs "twirp"}}.Error {
	statusCode := resp.StatusCode
	statusText := {{pkgs "http"}}.StatusText(statusCode)

	if isHTTPRedirect(statusCode) {
		// Unexpected redirect: it must be an error from an intermediary.
		// Twirp clients don't follow redirects automatically, Twirp only handles
		// POST requests, redirects should only happen on GET and HEAD requests.
		location := resp.Header.Get("Location")
		msg := {{pkgs "fmt"}}.Sprintf("unexpected HTTP status code %d %q received, Location=%q", statusCode, statusText, location)
		return twirpErrorFromIntermediary(statusCode, msg, location)
	}

	respBodyBytes, err := {{pkgs "ioutil"}}.ReadAll(resp.Body)
	if err != nil {
		return clientError("failed to read server error response body", err)
	}
	var tj twerrJSON
	if err := {{pkgs "json"}}.Unmarshal(respBodyBytes, &tj); err != nil {
		// Invalid JSON response; it must be an error from an intermediary.
		msg := {{pkgs "fmt"}}.Sprintf("Error from intermediary with HTTP status code %d %q", statusCode, statusText)
		return twirpErrorFromIntermediary(statusCode, msg, string(respBodyBytes))
	}

	errorCode := {{pkgs "twirp"}}.ErrorCode(tj.Code)
	if !{{pkgs "twirp"}}.IsValidErrorCode(errorCode) {
		msg := "invalid type returned from server error response: " + tj.Code
		return {{pkgs "twirp"}}.InternalError(msg)
	}

	twerr := {{pkgs "twirp"}}.NewError(errorCode, tj.Msg)
	for k, v := range tj.Meta {
		twerr = twerr.WithMeta(k, v)
	}
	return twerr
}

// twirpErrorFromIntermediary maps HTTP errors from non-twirp sources to twirp errors.
// The mapping is similar to gRPC: https://github.com/grpc/grpc/blob/master/doc/http-grpc-status-mapping.md.
// Returned twirp Errors have some additional metadata for inspection.
func twirpErrorFromIntermediary(status int, msg string, bodyOrLocation string) {{pkgs "twirp"}}.Error {
	var code {{pkgs "twirp"}}.ErrorCode
	if isHTTPRedirect(status) { // 3xx
		code = {{pkgs "twirp"}}.Internal
	} else {
		switch status {
		case 400: // Bad Request
			code = {{pkgs "twirp"}}.Internal
		case 401: // Unauthorized
			code = {{pkgs "twirp"}}.Unauthenticated
		case 403: // Forbidden
			code = {{pkgs "twirp"}}.PermissionDenied
		case 404: // Not Found
			code = {{pkgs "twirp"}}.BadRoute
		case 429, 502, 503, 504: // Too Many Requests, Bad Gateway, Service Unavailable, Gateway Timeout
			code = {{pkgs "twirp"}}.Unavailable
		default: // All other codes
			code = {{pkgs "twirp"}}.Unknown
		}
	}

	twerr := {{pkgs "twirp"}}.NewError(code, msg)
	twerr = twerr.WithMeta("http_error_from_intermediary", "true") // to easily know if this error was from intermediary
	twerr = twerr.WithMeta("status_code", strconv.Itoa(status))
	if isHTTPRedirect(status) {
		twerr = twerr.WithMeta("location", bodyOrLocation)
	} else {
		twerr = twerr.WithMeta("body", bodyOrLocation)
	}
		return twerr
	}
	func isHTTPRedirect(status int) bool {
	return status >= 300 && status <= 399
}

// wrappedError implements the github.com/pkg/errors.Causer interface, allowing errors to be
// examined for their root cause.
type wrappedError struct {
	msg   string
	cause error
}

func wrapErr(err error, msg string) error { return &wrappedError{msg: msg, cause: err} }
func (e *wrappedError) Cause() error      { return e.cause }
func (e *wrappedError) Error() string     { return e.msg + ": " + e.cause.Error() }

// clientError adds consistency to errors generated in the client
func clientError(desc string, err error) {{pkgs "twirp"}}.Error {
	return {{pkgs "twirp"}}.InternalErrorWith(wrapErr(err, desc))
}

// badRouteError is used when the twirp server cannot route a request
func badRouteError(msg string, method, url string) {{pkgs "twirp"}}.Error {
	err := {{pkgs "twirp"}}.NewError({{pkgs "twirp"}}.BadRoute, msg)
	err = err.WithMeta("twirp_invalid_route", method+" "+url)
	return err
}

// The standard library will, by default, redirect requests (including POSTs) if it gets a 302 or
// 303 response, and also 301s in go1.8. It redirects by making a second request, changing the
// method to GET and removing the body. This produces very confusing error messages, so instead we
// set a redirect policy that always errors. This stops Go from executing the redirect.
//
// We have to be a little careful in case the user-provided {{pkgs "http"}}.Client has its own CheckRedirect
// policy - if so, we'll run through that policy first.
//
// Because this requires modifying the {{pkgs "http"}}.Client, we make a new copy of the client and return it.
func withoutRedirects(in *{{pkgs "http"}}.Client) *{{pkgs "http"}}.Client {
	copy := *in
	copy.CheckRedirect = func(req *{{pkgs "http"}}.Request, via []*{{pkgs "http"}}.Request) error {
		if in.CheckRedirect != nil {
			// Run the input's redirect if it exists, in case it has side effects, but ignore any error it
			// returns, since we want to use ErrUseLastResponse.
			err := in.CheckRedirect(req, via)
			_ = err // Silly, but this makes sure generated code passes errcheck -blank, which some people use.
		}
		return {{pkgs "http"}}.ErrUseLastResponse
	}
	return &copy
}

// doProtobufRequest is common code to make a request to the remote twirp service.
func doProtobufRequest(ctx {{pkgs "context"}}.Context, client HTTPClient, url string, in, out {{pkgs "proto"}}.Message) error {
	var err error
	reqBodyBytes, err := {{pkgs "proto"}}.Marshal(in)
	if err != nil {
		return clientError("failed to marshal proto request", err)
	}
	reqBody := {{pkgs "bytes"}}.NewBuffer(reqBodyBytes)
	if err = ctx.Err(); err != nil {
		return clientError("aborted because context was done", err)
	}

	req, err := newRequest(ctx, url, reqBody, "application/protobuf")
	if err != nil {
		return clientError("could not build request", err)
	}
	resp, err := client.Do(req)
	if err != nil {
		return clientError("failed to do request", err)
	}
	defer closebody(resp.Body)
	if err = ctx.Err(); err != nil {
		return clientError("aborted because context was done", err)
	}

	if resp.StatusCode != 200 {
		return errorFromResponse(resp)
	}

	respBodyBytes, err := {{pkgs "ioutil"}}.ReadAll(resp.Body)
	if err != nil {
		return clientError("failed to read response body", err)
	}
	if err = ctx.Err(); err != nil {
		return clientError("aborted because context was done", err)
	}

	if err = {{pkgs "proto"}}.Unmarshal(respBodyBytes, out); err != nil {
		return clientError("failed to unmarshal proto response", err)
	}
	return nil
}

// doJSONRequest is common code to make a request to the remote twirp service.
func doJSONRequest(ctx {{pkgs "context"}}.Context, client HTTPClient, url string, in, out {{pkgs "proto"}}.Message) error {
	var err error
	reqBody := {{pkgs "bytes"}}.NewBuffer(nil)
	marshaler := &{{pkgs "jsonpb"}}.Marshaler{OrigName: true}
	if err = marshaler.Marshal(reqBody, in); err != nil {
		return clientError("failed to marshal json request", err)
	}
	if err = ctx.Err(); err != nil {
		return clientError("aborted because context was done", err)
	}

	req, err := newRequest(ctx, url, reqBody, "application/json")
	if err != nil {
		return clientError("could not build request", err)
	}
	resp, err := client.Do(req)
	if err != nil {
		return clientError("failed to do request", err)
	}
	defer closebody(resp.Body)
	if err = ctx.Err(); err != nil {
		return clientError("aborted because context was done", err)
	}

	if resp.StatusCode != 200 {
		return errorFromResponse(resp)
	}

	unmarshaler := {{pkgs "jsonpb"}}.Unmarshaler{AllowUnknownFields: true}
	if err = unmarshaler.Unmarshal(resp.Body, out); err != nil {
		return clientError("failed to unmarshal json response", err)
	}
	if err = ctx.Err(); err != nil {
		return clientError("aborted because context was done", err)
	}
	return nil
}

// Call {{pkgs "twirp"}}.ServerHooks.RequestReceived if the hook is available
func callRequestReceived(ctx {{pkgs "context"}}.Context, h *{{pkgs "twirp"}}.ServerHooks) ({{pkgs "context"}}.Context, error) {
	if h == nil || h.RequestReceived == nil {
	return ctx, nil
	}
	return h.RequestReceived(ctx)
}

// Call {{pkgs "twirp"}}.ServerHooks.RequestRouted if the hook is available
func callRequestRouted(ctx {{pkgs "context"}}.Context, h *{{pkgs "twirp"}}.ServerHooks) ({{pkgs "context"}}.Context, error) {
	if h == nil || h.RequestRouted == nil {
		return ctx, nil
	}
	return h.RequestRouted(ctx)
}

// Call {{pkgs "twirp"}}.ServerHooks.ResponsePrepared if the hook is available
func callResponsePrepared(ctx {{pkgs "context"}}.Context, h *{{pkgs "twirp"}}.ServerHooks) {{pkgs "context"}}.Context {
	if h == nil || h.ResponsePrepared == nil {
		return ctx
	}
	return h.ResponsePrepared(ctx)
}

// Call {{pkgs "twirp"}}.ServerHooks.ResponseSent if the hook is available
func callResponseSent(ctx {{pkgs "context"}}.Context, h *{{pkgs "twirp"}}.ServerHooks) {
	if h == nil || h.ResponseSent == nil {
		return
	}
	h.ResponseSent(ctx)
}

// Call {{pkgs "twirp"}}.ServerHooks.Error if the hook is available
func callError(ctx {{pkgs "context"}}.Context, h *{{pkgs "twirp"}}.ServerHooks, err {{pkgs "twirp"}}.Error) {{pkgs "context"}}.Context {
	if h == nil || h.Error == nil {
		return ctx
	}
	return h.Error(ctx, err)
}
{{end}}

var {{.FileDescriptorName}} = []byte{
	// {{.FileDescriptorLen}} bytes of a gzipped FileDescriptorProto
	{{.FileDescriptor}}
}
`
