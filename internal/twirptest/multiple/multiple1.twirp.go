// Code generated by protoc-gen-twirp v5.1.0, DO NOT EDIT.
// source: multiple1.proto

/*
Package multiple is a generated twirp stub package.
This code was generated with github.com/twitchtv/twirp/protoc-gen-twirp v5.1.0.

test to make sure that multiple proto files in one package works


It is generated from these files:
	multiple1.proto
	multiple2.proto
*/
package multiple

import bytes "bytes"
import context "context"
import fmt "fmt"
import ioutil "io/ioutil"
import http "net/http"
import strings "strings"

import jsonpb "github.com/golang/protobuf/jsonpb"
import proto "github.com/golang/protobuf/proto"
import twirp "github.com/twitchtv/twirp"
import ctxsetters "github.com/twitchtv/twirp/ctxsetters"

// ==============
// Svc1 Interface
// ==============

type Svc1 interface {
	Send(context.Context, *Msg1) (*Msg1, error)
}

// ====================
// Svc1 Protobuf Client
// ====================

type svc1ProtobufClient struct {
	client twirp.HTTPClient
	urls   [1]string
}

// NewSvc1ProtobufClient creates a Protobuf client that implements the Svc1 interface.
// It communicates using Protobuf and can be configured with a custom twirp.HTTPClient.
func NewSvc1ProtobufClient(addr string, client twirp.HTTPClient) Svc1 {
	prefix := twirp.URLBase(addr) + Svc1PathPrefix
	urls := [1]string{
		prefix + "Send",
	}
	if httpClient, ok := client.(*http.Client); ok {
		return &svc1ProtobufClient{
			client: twirp.WithoutRedirects(httpClient),
			urls:   urls,
		}
	}
	return &svc1ProtobufClient{
		client: client,
		urls:   urls,
	}
}

func (c *svc1ProtobufClient) Send(ctx context.Context, in *Msg1) (*Msg1, error) {
	out := new(Msg1)
	err := twirp.DoProtobufRequest(ctx, c.client, c.urls[0], in, out)
	return out, err
}

// ================
// Svc1 JSON Client
// ================

type svc1JSONClient struct {
	client twirp.HTTPClient
	urls   [1]string
}

// NewSvc1JSONClient creates a JSON client that implements the Svc1 interface.
// It communicates using JSON and can be configured with a custom twirp.HTTPClient.
func NewSvc1JSONClient(addr string, client twirp.HTTPClient) Svc1 {
	prefix := twirp.URLBase(addr) + Svc1PathPrefix
	urls := [1]string{
		prefix + "Send",
	}
	if httpClient, ok := client.(*http.Client); ok {
		return &svc1JSONClient{
			client: twirp.WithoutRedirects(httpClient),
			urls:   urls,
		}
	}
	return &svc1JSONClient{
		client: client,
		urls:   urls,
	}
}

func (c *svc1JSONClient) Send(ctx context.Context, in *Msg1) (*Msg1, error) {
	out := new(Msg1)
	err := twirp.DoJSONRequest(ctx, c.client, c.urls[0], in, out)
	return out, err
}

// ===================
// Svc1 Server Handler
// ===================

type svc1Server struct {
	Svc1
	*twirp.ServerHooks
}

func NewSvc1Server(svc Svc1, hooks *twirp.ServerHooks) twirp.Server {
	return &svc1Server{
		Svc1:        svc,
		ServerHooks: hooks,
	}
}

// Svc1PathPrefix is used for all URL paths on a twirp Svc1 server.
// Requests are always: POST Svc1PathPrefix/method
// It can be used in an HTTP mux to route twirp requests along with non-twirp requests on other routes.
const Svc1PathPrefix = "/twirp/twirp.internal.twirptest.multiple.Svc1/"

func (s *svc1Server) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	ctx = ctxsetters.WithPackageName(ctx, "twirp.internal.twirptest.multiple")
	ctx = ctxsetters.WithServiceName(ctx, "Svc1")
	ctx = ctxsetters.WithResponseWriter(ctx, resp)

	var err error
	ctx, err = s.CallRequestReceived(ctx)
	if err != nil {
		s.WriteError(ctx, resp, err)
		return
	}

	if req.Method != "POST" {
		msg := fmt.Sprintf("unsupported method %q (only POST is allowed)", req.Method)
		err = twirp.BadRouteError(msg, req.Method, req.URL.Path)
		s.WriteError(ctx, resp, err)
		return
	}

	if strings.HasPrefix(req.URL.Path, Svc1PathPrefix) {
		switch req.URL.Path[len(Svc1PathPrefix):] {
		case "Send":
			s.serveSend(ctx, resp, req)
			return
		}
	}
	msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
	err = twirp.BadRouteError(msg, req.Method, req.URL.Path)
	s.WriteError(ctx, resp, err)
	return
}

func (s *svc1Server) serveSend(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	switch req.Header.Get("Content-Type") {
	case "application/json":
		s.serveSendJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveSendProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := twirp.BadRouteError(msg, req.Method, req.URL.Path)
		s.WriteError(ctx, resp, twerr)
	}
}

func (s *svc1Server) serveSendJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "Send")
	ctx, err = s.CallRequestRouted(ctx)
	if err != nil {
		s.WriteError(ctx, resp, err)
		return
	}

	defer func() {
		if err := req.Body.Close(); err != nil {
			s.Printf("error closing body: %q", err)
		}
	}()
	reqContent := new(Msg1)
	unmarshaler := jsonpb.Unmarshaler{AllowUnknownFields: true}
	if err = unmarshaler.Unmarshal(req.Body, reqContent); err != nil {
		err = twirp.WrapErr(err, "failed to parse request json")
		s.WriteError(ctx, resp, twirp.InternalErrorWith(err))
		return
	}

	// Call service method
	var respContent *Msg1
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if r := recover(); r != nil {
				s.WriteError(ctx, resp, twirp.InternalError("Internal service panic"))
				panic(r)
			}
		}()
		respContent, err = s.Send(ctx, reqContent)
	}()

	if err != nil {
		s.WriteError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.WriteError(ctx, resp, twirp.InternalError("received a nil *Msg1 and nil error while calling Send. nil responses are not supported"))
		return
	}

	ctx = s.CallResponsePrepared(ctx)

	var buf bytes.Buffer
	marshaler := &jsonpb.Marshaler{OrigName: true}
	if err = marshaler.Marshal(&buf, respContent); err != nil {
		err = twirp.WrapErr(err, "failed to marshal json response")
		s.WriteError(ctx, resp, twirp.InternalErrorWith(err))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.WriteHeader(http.StatusOK)
	if _, err = resp.Write(buf.Bytes()); err != nil {
		s.Printf("errored while writing response to client, but already sent response status code to 200: %s", err)
	}
	s.CallResponseSent(ctx)
}

func (s *svc1Server) serveSendProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "Send")
	ctx, err = s.CallRequestRouted(ctx)
	if err != nil {
		s.WriteError(ctx, resp, err)
		return
	}

	defer func() {
		if err := req.Body.Close(); err != nil {
			s.Printf("error closing body: %q", err)
		}
	}()
	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		err = twirp.WrapErr(err, "failed to read request body")
		s.WriteError(ctx, resp, twirp.InternalErrorWith(err))
		return
	}
	reqContent := new(Msg1)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		err = twirp.WrapErr(err, "failed to parse request proto")
		s.WriteError(ctx, resp, twirp.InternalErrorWith(err))
		return
	}

	// Call service method
	var respContent *Msg1
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if r := recover(); r != nil {
				s.WriteError(ctx, resp, twirp.InternalError("Internal service panic"))
				panic(r)
			}
		}()
		respContent, err = s.Send(ctx, reqContent)
	}()

	if err != nil {
		s.WriteError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.WriteError(ctx, resp, twirp.InternalError("received a nil *Msg1 and nil error while calling Send. nil responses are not supported"))
		return
	}

	ctx = s.CallResponsePrepared(ctx)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		err = twirp.WrapErr(err, "failed to marshal proto response")
		s.WriteError(ctx, resp, twirp.InternalErrorWith(err))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.WriteHeader(http.StatusOK)
	if _, err = resp.Write(respBytes); err != nil {
		s.Printf("errored while writing response to client, but already sent response status code to 200: %s", err)
	}
	s.CallResponseSent(ctx)
}

func (s *svc1Server) ServiceDescriptor() ([]byte, int) {
	return twirpFileDescriptor0, 0
}

func (s *svc1Server) ProtocGenTwirpVersion() string {
	return "v5.1.0"
}

var twirpFileDescriptor0 = []byte{
	// 114 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0xcf, 0x2d, 0xcd, 0x29,
	0xc9, 0x2c, 0xc8, 0x49, 0x35, 0xd4, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x52, 0x2c, 0x29, 0xcf,
	0x2c, 0x2a, 0xd0, 0xcb, 0xcc, 0x2b, 0x49, 0x2d, 0xca, 0x4b, 0xcc, 0xd1, 0x03, 0x73, 0x4b, 0x52,
	0x8b, 0x4b, 0xf4, 0x60, 0x2a, 0x95, 0xd8, 0xb8, 0x58, 0x7c, 0x8b, 0xd3, 0x0d, 0x8d, 0x12, 0xb8,
	0x58, 0x82, 0xcb, 0x92, 0x0d, 0x85, 0x22, 0xb8, 0x58, 0x82, 0x53, 0xf3, 0x52, 0x84, 0xd4, 0xf5,
	0x08, 0xea, 0xd5, 0x03, 0x69, 0x94, 0x22, 0x56, 0xa1, 0x13, 0x57, 0x14, 0x07, 0x4c, 0x20, 0x89,
	0x0d, 0xec, 0x3e, 0x63, 0x40, 0x00, 0x00, 0x00, 0xff, 0xff, 0x93, 0xbf, 0xe2, 0x78, 0xb2, 0x00,
	0x00, 0x00,
}
